// server.js
import express from "express";
import crypto from "crypto";
import { Pool } from "pg";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.use(express.json());

// ---- config
const PORT = process.env.PORT || 10000;
const ADMIN_TOKEN = process.env.ADMIN_TOKEN || process.env.ADMIN || "";
const DB_URL = process.env.DATABASE_URL || process.env.SUPABASE_URL || "";

// ---- db pool (TLS tolerated for poolers etc.)
let pool = null;
if (DB_URL) {
  pool = new Pool({
    connectionString: DB_URL,
    ssl: { rejectUnauthorized: false },
  });
}

// ---- static sites
// root site (your existing /public)
app.use(express.static(path.join(__dirname, "public")));

// admin console at /console (your console/public)
app.use("/console", express.static(path.join(__dirname, "console", "public")));

// ---- health & diag
app.get("/health", (req, res) => {
  res.json({ ok: true });
});

app.get("/__diag", async (req, res) => {
  const diag = { ok: true, env: { has_port: !!PORT, has_db_url: !!DB_URL } };
  if (!pool) return res.status(200).json({ ...diag, db_ok: false, error: "no_pool" });
  try {
    const c = await pool.connect();
    try {
      const host = c.connectionParameters.host;
      const port = String(c.connectionParameters.port || 5432);
      await c.query("select 1");
      res.json({ ...diag, db_ok: true, db_host: host, db_port: port });
    } finally {
      c.release();
    }
  } catch (e) {
    res.status(500).json({
      ...diag,
      db_ok: false,
      db_host: pool.options?.host,
      db_port: String(pool.options?.port || 5432),
      error: e.message || String(e),
    });
  }
});

// ---- admin auth
function auth(req, res, next) {
  const h = req.headers.authorization || "";
  const token = h.startsWith("Bearer ") ? h.slice(7) : "";
  if (ADMIN_TOKEN && token === ADMIN_TOKEN) return next();
  res.status(401).json({ error: "unauthorized" });
}

// ---- bootstrap schema
async function ensureSchema() {
  if (!pool) return;
  await pool.query(`CREATE EXTENSION IF NOT EXISTS pgcrypto`);
  await pool.query(`
    CREATE TABLE IF NOT EXISTS kb_chunks (
      id            uuid PRIMARY KEY DEFAULT gen_random_uuid(),
      content       text      NOT NULL,
      meta          jsonb,
      updated_at    timestamptz NOT NULL DEFAULT now(),
      content_hash  text      NOT NULL UNIQUE
    )
  `);
  await pool.query(`CREATE INDEX IF NOT EXISTS kb_chunks_updated_at_idx ON kb_chunks (updated_at DESC)`);
  await pool.query(`CREATE INDEX IF NOT EXISTS kb_chunks_meta_gin_idx   ON kb_chunks USING GIN (meta)`);
}

// ---- admin kb endpoints
app.get("/admin/kb/count", auth, async (req, res) => {
  if (!pool) return res.status(500).json({ error: "no_pool" });
  const r = await pool.query("select count(*)::int as n from kb_chunks");
  res.json({ count: r.rows[0].n });
});

app.get("/admin/kb/list", auth, async (req, res) => {
  if (!pool) return res.status(500).json({ error: "no_pool" });
  const limit = Math.min(parseInt(req.query.limit || "10", 10), 100);
  const r = await pool.query(
    `select id, content, meta, updated_at, content_hash
     from kb_chunks
     order by updated_at desc
     limit $1`,
    [limit]
  );
  res.json({ items: r.rows });
});

app.post("/admin/kb", auth, async (req, res) => {
  if (!pool) return res.status(500).json({ error: "no_pool" });
  const content = (req.body?.content || "").toString();
  const meta = req.body?.meta ?? {};
  if (!content.trim()) return res.status(400).json({ error: "content_required" });
  const hash = crypto.createHash("sha256").update(content, "utf8").digest("hex");
  try {
    const r = await pool.query(
      `insert into kb_chunks (content, meta, content_hash)
       values ($1, $2, $3)
       on conflict (content_hash) do nothing
       returning id, content_hash`,
      [content, meta, hash]
    );
    if (r.rows.length) return res.json(r.rows[0]);
    res.json({ duplicate: true, content_hash: hash });
  } catch (e) {
    res.status(500).json({ error: e.message || String(e) });
  }
});

// ---- listen + init
app.listen(PORT, async () => {
  try { await ensureSchema(); } catch {}
});
